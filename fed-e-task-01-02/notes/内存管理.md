# JavaScript 性能优化

## 内存管理
```javascript
function fn(){
    arrList = [];
    arrList[100000] = 'lg is a coder'
}
fn();
```
* 内存：由可读单元组成，表示一片可操作空间
* 管理：人为的去操作一片空间的申请、使用和释放
* 内存管理：开发者主动申请空间、使用空间、释放空间
* 管理流程：申请-使用-释放

```javascript
//申请空间
let obj= {};

//使用
obj.name = 'lg'

//释放
obj= null
```
## JavaScript 中的垃圾回收


JavaScript 中的垃圾
* javascript中内存管理是自动的
* 对象不再被引用时是垃圾
* 对象不能从根上访问到时是垃圾


JavaScript中的可达对象
* 可以访问到的对象就是可达对象（引用、作用域链）
* 可达的标准就是从根出发是否能够被找到
* JavaScript中的跟就可以理解为是全局变量对象

JavaScript的引用和可达
```javascript
let obj = {name:'xm'}
let ali = obj;
obj = null;
```

```javascript
function objGroup(obj1,obj2){
    obj1.next = obj2;
    obj2.prev = obj1;
    return {
        o1:obj1,
        o2:obj2
    }
}
let obj = objGroup({name:'oobj1'},{name:'obj2'})

console.log(obj);
```

## GC算法

GC定义
* GC就是垃圾回收机制的简写
* GC可以找到内存中的垃圾、并释放和回收空间

GC里的垃圾是什么
* 程序中不再需要使用的对象
  ```javascript
  function func(){
      name = 'lg'
      return  `${name} is a coder`
  }
  func()
  ```
* 程序中不能再访问到的对象
  ```javascript
  function func(){
      const name = 'lg'
      return  `${name} is a coder`
  }
  func()
  ```

GC算法是什么
* GC就是一种机制，垃圾回收器完成具体的工作
* 工作内容就是查找垃圾释放空间、回收空间
* 算法就是工作时查找和回收所遵循的规则

常见的GC算法
* 引用计数
* 标记清除
* 标记整理
* 分代回收

引用计数算法
* 核心思想：设置引用数，判断当前引用数是否为0
* 引用计数器
* 引用关系改变时修改引用数字
* 引用数字为0时立即回收

```javascript
const user1 = {age:11}
const user2 = {age:22}
const user3 = {age:33}
const nameList = [user1.age,user2.age,user3.age]
function fn(){
    const num1 = 1;
    const num2 = 2;
}
fn();
```
引用计数算法优点
* 发现垃圾时立即回收
* 最大限度减少程序暂停

引用计数算法缺点
* 无法回收循环引用的对象
* 时间开销大

## 标记清除算法
* 核心思想：分标记和清除两个阶段完成
* 遍历所有对象找标记活动对象（找到所有可达对象，进行标记）
* 遍历所有对象清除没有标记对象
* 回收相应的空间
优缺点：
* 优点：解决引用计算算法循环引用不能回收问题
* 缺点:空间碎片化


## 标记整理算法
* 标记整理算法可以看做是标记清除的增强
* 标记阶段的操作和标记清除一致
* 清除阶段会先执行整理，移动活动对象位置


## GC算法总结
* 引用计数
  * 可以及时回收垃圾对象
  * 减少程序卡顿时间
  * 无法回收循环引用的对象
  * 资源消耗较大
* 标记清除
  * 可以回收循环引用的对象
  * 容易产生碎片化空间，浪费空间
  * 不会立即回收垃圾对象
* 标记整理
  * 减少碎片化空间
  * 不会立即回收垃圾对象


## V8引擎
* V8是一款主流的JavaScript执行引擎  （chrome浏览器，node）
* V8采用即时编辑
* V8内存设限     64位  1.5G   32位 800M

## V8回收策略
* 采用分代回收的思想
* 内存分为新生代、老生代
* 针对不同对象采用不同的算法
常用的GC算法
* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量
V8 内存分配
From  To    老生代存储区


## 回收新生代
* V8内存空间一分为二
* 小空间用于存储新生代对象   64位  32M   32位：16M
* 新生代指的是存活时间较短的对象    (局部作用域里变量)
回收实现
* 回收过程采用复制算法+标记整理
* 新生代内存区分为两个等大小空间
* 使用空间为From，空闲空间为To
* 活动对象存储于From空间
* 标记整理后将活动对象拷贝至To  （触发GC时）
* From与To交换后完成释放   （From空间完全释放，From 变成To，To变成From）
* 拷贝过程中可能出现晋升
* 晋升就是将新生代对象移动至老生代
  * 一轮GC还存活的新生代需要晋升
  * To空间的使用率超过25%

## 回收老生代
* 老生代对象存放在老生代区域
* 64位 1.4G   32位 700M
* 老生代对象就是指存活时间较长的对象   （全局对象，闭包产生的对象）
回收实现
* 主要采用标记清除、标记整理、增量标记算法
* 首先使用标记清除完成垃圾空间的回收
* 采用标记整理进行空间优化  （新生代对象晋升、空间不足）
* 采用增量标记进行效率优化
细节对比
* 新生代使用空间换时间
* 老生代不适合复制算法   （空间浪费大，存储大效率不高）

标记增量
* 遍历对象进行标记  （并不一次性执行完）
* 与程序执行交替执行

## v8总结
* v8是一款主流的JavaScript执行引擎
* v8内存设置上限
* v8采用基于分代回收思想实现垃圾回收
* v8内存分为新生代和老生代
* v8垃圾回收常见的GC算法   新生代：复制+标记整理  老生代：标记清除+标记整理+增量标记
